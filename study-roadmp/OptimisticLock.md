# 낙관적 락 (Optimistic Lock)

## 개요

낙관적 락(Optimistic Lock)은  
**데이터 충돌이 잘 발생하지 않을 것이라는 가정** 하에,  
락을 걸지 않고 우선 데이터를 수정한 뒤, **최종 커밋 시점에 충돌 여부를 확인**하는 방식이다.

"다른 트랜잭션이 이 데이터를 수정할 가능성이 낮다"는 **낙관적인 가정**을 전제로 한다.

---

## 주요 특징

- 데이터를 수정할 때 **실제 락을 걸지 않음**
- 대신 버전 번호(`version`)나 타임스탬프 등을 이용해 충돌을 감지
- 충돌 발생 시 예외를 발생시키고, **트랜잭션을 롤백하거나 재시도**

---

## 사용 예시 (JPA)

### 1. 엔티티에 버전 필드 추가

```java
@Entity
public class Member {
    @Id
    private Long id;

    private String name;

    @Version
    private int version; // 낙관적 락을 위한 버전 필드
}
```

### 2. 동작 방식

- 조회 시: `SELECT id, name, version FROM member WHERE id = 1`
- 수정 후 커밋 시:
  ```sql
  UPDATE member SET name = ?, version = version + 1 WHERE id = ? AND version = ?
  ```

- 만약 다른 트랜잭션이 먼저 version을 증가시켰다면,  
  `UPDATE`는 0건에 영향을 미치게 되어 예외 발생 → `OptimisticLockException`

---

## 장점

- **동시성에 강함**: 락을 걸지 않으므로 병렬 처리에 유리
- **데드락 발생 없음**
- 성능 부담 적음

---

## 단점

- 충돌 발생 시 롤백/재시도 로직 필요
- **충돌 가능성이 높은 경우 성능 저하** (낙관이 실패함)

---

## 언제 사용할까?

| 상황 | 설명 |
|------|------|
| 충돌 가능성이 낮은 경우 | 예: 대부분 읽기 전용이거나, 사용자 간 데이터 충돌이 드문 경우 |
| 고성능 요구되는 경우 | 락 없이 처리하여 트래픽을 감당 가능 |
| 재시도 로직이 감당 가능한 경우 | 충돌 발생 시 비즈니스 로직에서 재처리 가능해야 함 |

---

## 비관적 락과 비교

| 항목 | 낙관적 락 | 비관적 락 |
|------|------------|------------|
| 락 방식 | 락 없음, 버전 비교 | `SELECT ... FOR UPDATE`, DB 락 |
| 충돌 처리 | 나중에 검증 (실패 시 예외) | 선제적으로 차단 |
| 성능 | 높음 (락 없음) | 낮음 (락 유지) |
| 데드락 | 없음 | 발생 가능 |
| 예외 발생 시 | 재시도 필요 | 대부분 대기 또는 실패 |

---

## 요약

> 낙관적 락은 **락을 걸지 않고 데이터를 수정한 뒤**,  
> **버전 등을 통해 충돌을 확인하는 방식**으로,  
> **충돌 가능성이 낮은 환경에서 높은 동시성과 성능을 제공**한다.
