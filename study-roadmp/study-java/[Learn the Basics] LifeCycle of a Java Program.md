# Lifecycle of a Java Program

## 전체 단계 요약

| 구분 | 큰 단계 | 내부 세부 단계 |
|------|---------|----------------|
| 1. 컴파일 | .java → .class | javac 컴파일러가 바이트코드 생성 (JVM 외부에서 실행됨) |
| 2. 클래스 로딩 | ClassLoader가 .class 읽기 | 로딩 → 링킹 → 초기화 |
| 3. 바이트코드 실행 | main()부터 실제 실행 | 인스턴스화, 종료처리, 언로딩 등 실행과 메모리 정리 과정 |

---

## 1. 컴파일 (Compilation)
1. 자바 소스 코드(`.java`)는 `javac` 컴파일러를 통해 **바이트코드(`.class`)로 변환**됩니다.
2. 이 바이트코드는 **플랫폼 독립적인 중간 표현**으로, JVM에서 실행됩니다.
3. ➕ 플랫폼 독립성이란?
    - 바이트코드는 CPU가 직접 이해하는 기계어가 아니라, **JVM이 이해하는 코드**입니다.
    - 즉, **JVM만 설치되어 있다면** 어떤 운영체제에서도 `.class` 파일을 실행할 수 있습니다.

---

## 2. 클래스 로딩 (Class Loading)
1. JVM은 **클래스 로더(ClassLoader)**를 사용해 필요한 `.class` 파일을 **JVM 메모리로 로드**합니다.
2. 주요 클래스 로더:
    - **부트스트랩 클래스 로더**: 핵심 Java API 클래스 로드 (예: `java.lang.*`)
    - **확장 클래스 로더**: `ext` 디렉토리의 클래스를 로드
    - **시스템 클래스 로더**: 클래스패스의 애플리케이션 클래스를 로드
3. 사용자 정의 클래스 로더를 통해 **특정 요구에 맞게 동적으로 클래스 로딩**도 가능합니다.
4. 로딩 과정은 다음 세 단계로 이루어집니다:

    #### 2-1. 로딩 (Loading)
    - `.class` 파일을 찾아 **JVM 메모리(Method Area/Metaspace)**에 올리고, `Class` 객체를 생성합니다.

    #### 2-2. 링킹 (Linking)
    - **검증 (Verification)**: 바이트코드 유효성 검사
    - **준비 (Preparation)**: static 변수용 메모리 할당 및 기본값 초기화
    - **해결 (Resolution)**: 심볼릭 참조를 실제 메모리 주소로 바인딩

    #### 2-3. 초기화 (Initialization)
    - static 초기화 블록 등 실행하여 static 변수 초기값 지정

---

## 3. 바이트코드 실행 (Bytecode Execution)
1. JVM은 메모리에 올라온 바이트코드를 **실행 시점에 기계어로 변환(JIT)**하여 실행합니다.
2. 실행 시 주요 단계는 다음과 같습니다:

    #### 3-1. 인스턴스화 (Instantiation)
    - `new` 키워드 등을 통해 객체 생성 → 생성자 호출로 필드 초기화

    #### 3-2. 종료 처리 (Finalization)
    - 객체가 더 이상 필요 없어질 경우, `finalize()`가 호출될 수 있음  
      (⚠️ 현재는 거의 사용되지 않고, GC가 자동 관리함)

    #### 3-3. 언로딩 (Unloading)
    - 클래스가 더 이상 필요 없을 경우, JVM이 메모리에서 제거 (언로드)