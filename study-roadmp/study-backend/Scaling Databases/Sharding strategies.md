# 샤딩 (Sharding) 정리

## 개념
- 데이터를 나누어 여러 DB에 저장하는 분산 전략
- 주로 쓰기 성능 향상, 저장 용량 확장, 트래픽 분산 목적

## 샤딩 방식

| 방식 | 설명 | 장점 | 단점 |
|------|------|------|------|
| 수직 샤딩 | 테이블의 컬럼 단위로 나눔 | 간단한 분리 | 컬럼 간 조인 어려움 |
| 수평 샤딩 | 테이블의 행(Row)을 기준으로 분리 | 확장성 우수 | 트랜잭션, 조인 어려움 |
| 범위 기반 | ID 범위로 나눔 | 범위 쿼리에 유리 | 데이터 쏠림 가능 |
| 해시 기반 | ID를 해시로 분산 | 균등 분산 | 범위 조회 어려움 |
| 디렉토리 기반 | 매핑 테이블로 샤드 위치 관리 | 유연한 이동 | 매핑 관리 필요 |

## 논리적 샤드 vs 물리적 샤드

| 항목 | 설명 |
|------|------|
| 논리적 샤드 | 데이터를 분할하는 로직상의 단위 (예: user_id % 1024) |
| 물리적 샤드 | 실제 데이터가 저장되는 DB 인스턴스 (예: MySQL 서버) |
| 라우터 | 논리 샤드를 물리 샤드로 매핑하는 계층 (ex. shard_map 사용) |

## 실무 전략
- 논리 샤드는 넉넉하게 미리 설계 (예: 1024개)
- 일부만 물리 샤드에 매핑하여 운영 후, 필요 시 확장
- 디렉토리 기반 매핑(shard_map 테이블)을 통해 유연한 샤드 이동 가능
- 샤드 키는 균등 분산을 고려해 `user_id`, `UUID hash` 등으로 선택

## 라우팅 (Routing)

### 개념
- 라우팅이란, 애플리케이션이 계산한 논리 샤드 번호(logical shard key)를 기반으로,
  해당 데이터가 저장되어야 할 물리 DB(physical database)를 동적으로 결정하는 과정입니다.
- RDBMS(MySQL, PostgreSQL 등)는 샤딩이나 라우팅 개념을 알지 못하므로,
  이 기능은 전적으로 애플리케이션 또는 미들웨어에서 처리해야 합니다.

---

### 구성 요소

| 구성 요소      | 설명 |
|----------------|------|
| 논리 샤드 번호 | 보통 user_id, content_id 등을 기준으로 `%` 연산으로 계산 |
| 물리 DB        | 실제 데이터를 저장하는 MySQL/PostgreSQL 인스턴스 |
| shard_map      | 논리 샤드 번호 → 물리 DB 매핑 정보 (DB 테이블로 관리) |
| 라우터         | shard_map을 참조하여 요청을 어떤 DB로 보낼지 결정하는 컴포넌트 |

---

### 예시 흐름

#### 1. 논리 샤드 번호 계산

```java
int shardKey = userId % 1024;
```

#### 2. shard_map에서 물리 DB 정보 조회

```java
String dbName = shardMapRepository.findByShardKey(shardKey); // 예: "db3"
```

#### 3. 해당 DB에만 쿼리 전송

```java
DataSource target = dataSourceRouter.resolve(dbName);
ShardRoutingContext.set(dbName); // ThreadLocal 활용
```

---

### shard_map의 유용성

| 특징           | 설명 |
|----------------|------|
| 유연한 확장     | 논리 샤드 수(예: 1024)는 고정, 물리 DB 매핑만 유동적으로 변경 가능 |
| 무중단 리밸런싱 | shard_map만 수정하면 코드 변경 없이 샤드 재배치 가능 |
| 운영 독립성     | DB 추가, 이관, 리밸런싱 등 운영 작업이 코드에 영향을 주지 않음 |

---

### 운영 중 shard_map 변경 예

#### 초기 상태

| 논리 샤드 | 물리 DB |
|-----------|----------|
| 0~1023    | db1      |

#### 변경 후

| 논리 샤드 | 물리 DB |
|-----------|----------|
| 0~511     | db1      |
| 512~1023  | db2      |

→ shard_map 테이블만 바꾸면 다음 요청부터는 자동으로 db2로 라우팅  
→ 데이터는 별도 마이그레이션 스크립트로 이전

---

### 요약

- 라우팅은 “논리 샤드 번호 → 물리 DB”를 결정하는 단계
- 논리 샤드 번호는 애플리케이션에서 계산하고,
- shard_map이 어떤 DB에 쿼리를 보낼지를 결정
- 이를 통해 코드 수정 없이도 샤드 확장 및 분산이 가능

---

## 참고 강의
[스프링부트로 대규모 시스템 설계 - 게시판 프로젝트](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EB%A1%9C-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%84%A4%EA%B3%84-%EA%B2%8C%EC%8B%9C%ED%8C%90/dashboard)

---

### ++ 라우팅 관련 질문 정리

#### Q1. 논리적 샤드는 어떻게 사용하는 거야? DB는 그걸 모르지 않아?

- 맞아요. **DB는 논리 샤드 개념을 알지 못합니다.**
- 논리적 샤드는 오직 **애플리케이션에서 데이터를 분산시키기 위한 계산 단위**입니다.
- 예: `user_id % 1024` → 논리 샤드 번호
- 이 번호를 기준으로 `shard_map`에서 어떤 물리 DB로 보낼지 결정해줍니다.

---

#### Q2. 그럼 논리 샤드 1024개 중 일부만 쓴다면 나중에 매핑은 바꿔야 하지 않아?

- 맞습니다. **논리 샤드는 고정되지만, 물리 DB 매핑은 유동적입니다.**
- 초기에는 `0~1023` 전부를 `DB1`에 매핑해 두었다가,
- 추후 트래픽이 많아지면 아래처럼 분산합니다:

| 논리 샤드 번호 | 물리 DB |
|----------------|----------|
| 0~511          | DB1      |
| 512~1023       | DB2      |

- 이때 필요한 건 `shard_map` 테이블만 수정하는 것 — **코드는 그대로!**

---

#### Q3. shard_map을 바꾸면 애플리케이션에 영향은 없어?

- 거의 없습니다.
- 이유는:
  - 라우팅은 항상 `shard_map`을 참조하기 때문에
  - 이 테이블만 바꾸면 다음 요청부터는 새 DB로 자동 라우팅됩니다
- **단**, 기존 데이터는 마이그레이션 필요 (예: batch로 DB1 → DB2 이동)

---

#### Q4. 그럼 shard_map은 누가, 어디서 관리해?

- 일반적으로 **애플리케이션이 shard_map 테이블을 조회해서 사용**합니다.
- shard_map은:
  - DB에 저장하거나
  - Redis 등에 캐싱하거나
  - config 파일 등으로 관리 가능
- 실무에서는 shard_map을 DB에 테이블로 두고, 운영자/배치 작업자가 직접 업데이트합니다.

---

#### Q5. 물리 DB(DB1, DB2...)는 분리되어 있어?

- **실무에서는 대부분 분리합니다.**
  - DB1: 서버 A의 MySQL
  - DB2: 서버 B의 MySQL
- 그래야 진짜 **수평 확장(Scale-out)** 이 가능하고,
- **서버 단위로 부하 분산 및 장애 격리**도 할 수 있습니다.
- 개발 초기에는 하나의 MySQL에 여러 DB(post_0, post_1...)로 구성하기도 하지만, 운영에서는 분리 권장

---

#### Q6. 물리 DB가 논리 샤드와 대응되는 방식이 궁금해

- DB 자체는 논리 샤드를 모릅니다.
- 오직 애플리케이션이 `user_id → 논리 샤드 번호 → shard_map → 물리 DB` 로 계산해서 쿼리를 날릴 뿐입니다.
- 즉, DB는 그저 “지정된 쿼리를 처리하는 하나의 저장소”일 뿐입니다.

---

#### Q7. 그럼 DB에 데이터는 정렬되어 있는 거야?

- 아니요. **각 DB는 독립적으로 존재하고, 데이터는 정렬되어 있지 않습니다.**
- `id = 1`이 DB1, DB2, DB3에 각각 존재할 수 있습니다.
- 전체 정렬된 데이터를 얻으려면:
  - 각 샤드에서 정렬된 데이터 조회 (LIMIT 10)
  - 애플리케이션에서 merge sort 등으로 합치기
